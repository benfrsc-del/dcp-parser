<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCP Parser - AI-Ready Format Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.1rem;
            color: #666;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .api-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .api-section h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .api-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .api-note {
            font-size: 0.9rem;
            color: #856404;
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #ddd;
            transition: all 0.3s ease;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: scale(1.02);
        }

        .file-input-container {
            text-align: center;
            position: relative;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .file-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .file-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .file-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f1b0b7;
        }

        .processing-section {
            display: none;
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .processing-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .step {
            flex: 1;
            min-width: 180px;
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .step.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.05);
        }

        .step.completed {
            background: #28a745;
            color: white;
        }

        .step-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.5s ease;
        }

        .results-section {
            display: none;
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .output-tabs {
            display: flex;
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 5px;
            flex-wrap: wrap;
        }

        .tab-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
            min-width: 120px;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .output-content {
            display: none;
        }

        .output-content.active {
            display: block;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .download-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .download-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .control-buttons {
            text-align: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            margin: 0 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .embedding-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .embedding-status.generating {
            background: #e7f3ff;
            color: #0066cc;
            border: 1px solid #b3d9ff;
        }

        .embedding-status.complete {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .embedding-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f1b0b7;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .processing-steps {
                flex-direction: column;
            }
            
            .output-tabs {
                flex-direction: column;
            }
            
            .download-buttons {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DCP Parser</h1>
            <p>Transform Development Control Plans into AI-ready formats. Upload your PDF documents and get structured JSON, XML, and vector embeddings for machine learning applications.</p>
        </div>

        <div class="api-section">
            <h3>OpenAI Integration (Optional)</h3>
            <input type="password" id="apiKey" class="api-input" placeholder="Enter your OpenAI API key (sk-...)">
            <div class="api-note">
                <strong>Note:</strong> API key is used only for generating real vector embeddings. Without it, simulated embeddings will be created. Your key is stored locally in your browser and never sent anywhere except OpenAI's servers.
                <br><strong>Cost:</strong> Typically $0.02-0.05 per document depending on size.
            </div>
            <div class="embedding-status" id="embeddingStatus" style="display: none;"></div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="file-input-container">
                <input type="file" id="fileInput" class="file-input" accept=".pdf" multiple>
                <label for="fileInput" class="file-input-label">
                    Select DCP Files or Drag & Drop
                </label>
                <p style="margin-top: 15px; color: #666;">Supports PDF files up to 50MB each. Multiple files can be processed together.</p>
            </div>
            <div class="file-status" id="fileStatus"></div>
        </div>

        <div class="processing-section" id="processingSection">
            <h2>Processing Your Documents</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="processing-steps">
                <div class="step" id="step1">
                    <div class="step-icon">üì§</div>
                    <h3>Upload</h3>
                    <p>Reading PDF files</p>
                </div>
                <div class="step" id="step2">
                    <div class="step-icon">üîç</div>
                    <h3>Extract</h3>
                    <p>Parsing content</p>
                </div>
                <div class="step" id="step3">
                    <div class="step-icon">üß†</div>
                    <h3>Analyze</h3>
                    <p>AI processing</p>
                </div>
                <div class="step" id="step4">
                    <div class="step-icon">üîó</div>
                    <h3>Embed</h3>
                    <p>Vector generation</p>
                </div>
                <div class="step" id="step5">
                    <div class="step-icon">üìä</div>
                    <h3>Structure</h3>
                    <p>Creating formats</p>
                </div>
                <div class="step" id="step6">
                    <div class="step-icon">‚úÖ</div>
                    <h3>Complete</h3>
                    <p>Ready to download</p>
                </div>
            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <h2>Parsing Results</h2>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="statPages">0</div>
                    <div class="stat-label">Pages Processed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statSections">0</div>
                    <div class="stat-label">Sections Found</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statRules">0</div>
                    <div class="stat-label">Development Rules</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statZones">0</div>
                    <div class="stat-label">Zoning Areas</div>
                </div>
            </div>

            <div class="output-tabs">
                <button class="tab-button active" onclick="showTab('json')">JSON Output</button>
                <button class="tab-button" onclick="showTab('xml')">XML Output</button>
                <button class="tab-button" onclick="showTab('summary')">Summary</button>
                <button class="tab-button" onclick="showTab('embeddings')">Vector Data</button>
            </div>

            <div class="output-content active" id="jsonOutput">
                <h3>Structured JSON Format</h3>
                <div class="code-block" id="jsonCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('json')">Download JSON</button>
                </div>
            </div>

            <div class="output-content" id="xmlOutput">
                <h3>XML Schema Format</h3>
                <div class="code-block" id="xmlCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('xml')">Download XML</button>
                </div>
            </div>

            <div class="output-content" id="summaryOutput">
                <h3>Document Analysis Summary</h3>
                <div class="code-block" id="summaryCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('summary')">Download Summary</button>
                </div>
            </div>

            <div class="output-content" id="embeddingsOutput">
                <h3>Vector Embeddings for AI/ML</h3>
                <div class="code-block" id="embeddingsCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('embeddings')">Download Vectors</button>
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" onclick="processAnotherFile()">Process Another File</button>
                <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        let processedData = {};
        let currentFiles = [];

        // File input handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const fileStatus = document.getElementById('fileStatus');
        const embeddingStatus = document.getElementById('embeddingStatus');

        fileInput.addEventListener('change', handleFileSelect);
        uploadSection.addEventListener('dragover', handleDragOver);
        uploadSection.addEventListener('drop', handleDrop);
        uploadSection.addEventListener('dragleave', handleDragLeave);

        // Test PDF.js availability on page load
        window.addEventListener('load', function() {
            if (typeof pdfjsLib === 'undefined') {
                showFileStatus('Warning: PDF.js failed to load. Check your internet connection.', 'error');
            } else {
                console.log('PDF.js loaded successfully. Ready to process PDF files.');
            }
        });

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                // Validate file types
                const invalidFiles = files.filter(f => f.type !== 'application/pdf');
                if (invalidFiles.length > 0) {
                    showFileStatus(`Invalid file types detected: ${invalidFiles.map(f => f.name).join(', ')}. Only PDF files are supported.`, 'error');
                    return;
                }

                currentFiles = files;
                showFileStatus(`Selected ${files.length} file(s): ${files.map(f => f.name).join(', ')}`, 'success');
                setTimeout(() => processFiles(files), 1000);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            uploadSection.classList.add('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = Array.from(event.dataTransfer.files).filter(f => f.type === 'application/pdf');
            if (files.length > 0) {
                currentFiles = files;
                showFileStatus(`Dropped ${files.length} file(s): ${files.map(f => f.name).join(', ')}`, 'success');
                setTimeout(() => processFiles(files), 1000);
            } else {
                showFileStatus('Please drop PDF files only', 'error');
            }
        }

        function handleDragLeave(event) {
            uploadSection.classList.remove('dragover');
        }

        function showFileStatus(message, type) {
            fileStatus.textContent = message;
            fileStatus.className = `file-status ${type}`;
            fileStatus.style.display = 'block';
        }

        function showEmbeddingStatus(message, type) {
            embeddingStatus.textContent = message;
            embeddingStatus.className = `embedding-status ${type}`;
            embeddingStatus.style.display = 'block';
        }

        async function processFiles(files) {
            document.getElementById('processingSection').style.display = 'block';
            
            let totalPages = 0;
            let allContent = '';
            let sections = [];
            let developmentRules = [];
            let zoningAreas = [];

            // Step 1: Upload
            updateProgress(15, 1);
            await sleep(500);

            try {
                // Step 2: Extract
                updateProgress(30, 2);
                
                for (const file of files) {
                    try {
                        const result = await extractTextFromPDF(file);
                        allContent += result.text + '\n\n';
                        totalPages += result.numPages;
                        
                        // Parse content for DCP-specific elements
                        const parsed = parseDCPContent(result.text, file.name);
                        sections.push(...parsed.sections);
                        developmentRules.push(...parsed.rules);
                        zoningAreas.push(...parsed.zones);
                        
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        showFileStatus(`Error processing ${file.name}: ${error.message}`, 'error');
                        
                        // Add error section for failed processing
                        sections.push({
                            title: `Processing Error - ${file.name}`,
                            content: `Failed to extract content from ${file.name}. Error: ${error.message}`,
                            source: file.name
                        });
                    }
                }

                // Step 3: Analyze
                updateProgress(50, 3);
                await sleep(800);

                // Step 4: Generate Embeddings
                updateProgress(70, 4);
                const apiKey = document.getElementById('apiKey').value.trim();
                let embeddingsData;

                if (apiKey) {
                    try {
                        showEmbeddingStatus('Generating real vector embeddings with OpenAI...', 'generating');
                        embeddingsData = await generateRealEmbeddings(sections, apiKey);
                        showEmbeddingStatus(`‚úì Generated ${embeddingsData.embeddings.length} real embeddings`, 'complete');
                    } catch (error) {
                        console.error('Embedding generation failed:', error);
                        showEmbeddingStatus(`Embedding generation failed: ${error.message}. Using simulated embeddings.`, 'error');
                        embeddingsData = generateSimulatedEmbeddings(sections);
                    }
                } else {
                    embeddingsData = generateSimulatedEmbeddings(sections);
                    showEmbeddingStatus('Using simulated embeddings (no API key provided)', 'complete');
                }

                // Step 5: Structure
                updateProgress(85, 5);
                await sleep(500);

                // Generate structured outputs
                processedData = generateStructuredOutputs({
                    files: files.map(f => f.name),
                    totalPages,
                    content: allContent,
                    sections,
                    developmentRules,
                    zoningAreas,
                    embeddings: embeddingsData
                });

                // Step 6: Complete
                updateProgress(100, 6);
                await sleep(500);

                // Update statistics
                document.getElementById('statPages').textContent = totalPages;
                document.getElementById('statSections').textContent = sections.length;
                document.getElementById('statRules').textContent = developmentRules.length;
                document.getElementById('statZones').textContent = zoningAreas.length;

                // Show results
                displayResults();

            } catch (error) {
                console.error('Processing error:', error);
                showFileStatus(`Processing failed: ${error.message}`, 'error');
            }
        }

        async function extractTextFromPDF(file) {
            if (!pdfjsLib) {
                throw new Error('PDF.js library not loaded. Check your internet connection.');
            }

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        let fullText = '';

                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            
                            // Extract text with better spacing
                            let pageText = '';
                            let lastY = -1;
                            
                            textContent.items.forEach(item => {
                                // Add line break if this is a new line (different Y position)
                                if (lastY !== -1 && Math.abs(item.transform[5] - lastY) > 5) {
                                    pageText += '\n';
                                }
                                pageText += item.str + ' ';
                                lastY = item.transform[5];
                            });
                            
                            fullText += pageText + '\n\n';
                        }

                        resolve({
                            text: fullText.trim(),
                            numPages: pdf.numPages
                        });
                    } catch (error) {
                        reject(new Error(`Failed to extract PDF text: ${error.message}`));
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        }

        async function generateRealEmbeddings(sections, apiKey) {
            const embeddings = [];
            let totalTokens = 0;
            
            for (let i = 0; i < sections.length; i++) {
                const section = sections[i];
                
                try {
                    // Chunk large sections
                    const chunks = chunkText(section.content, 8000); // OpenAI limit is ~8192 tokens
                    
                    for (let j = 0; j < chunks.length; j++) {
                        const response = await fetch('https://api.openai.com/v1/embeddings', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: "text-embedding-3-small",
                                input: chunks[j],
                                encoding_format: "float"
                            })
                        });
                        
                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(`OpenAI API Error: ${errorData.error?.message || response.statusText}`);
                        }
                        
                        const data = await response.json();
                        totalTokens += data.usage.total_tokens;
                        
                        embeddings.push({
                            chunk_id: `chunk_${i}_${j}`,
                            text: chunks[j].substring(0, 200) + (chunks[j].length > 200 ? "..." : ""),
                            vector: data.data[0].embedding,
                            metadata: {
                                source: section.source,
                                section_title: section.title,
                                chunk_type: "section_content",
                                chunk_index: j,
                                total_chunks: chunks.length,
                                word_count: chunks[j].split(' ').length
                            }
                        });
                        
                        // Rate limiting - OpenAI allows 3000 RPM for most users
                        await sleep(100);
                    }
                    
                } catch (error) {
                    console.error(`Error generating embedding for section ${i}:`, error);
                    throw error;
                }
            }
            
            return {
                embedding_model: "text-embedding-3-small",
                vector_dimensions: 1536,
                total_chunks: embeddings.length,
                total_tokens_used: totalTokens,
                estimated_cost: (totalTokens * 0.00002).toFixed(4), // $0.02 per 1M tokens
                embeddings: embeddings
            };
        }

        function generateSimulatedEmbeddings(sections) {
            return {
                embedding_model: "simulated",
                vector_dimensions: 1536,
                total_chunks: sections.length,
                embeddings: sections.slice(0, 10).map((section, index) => ({
                    chunk_id: `chunk_${index}`,
                    text: section.content.substring(0, 200) + (section.content.length > 200 ? "..." : ""),
                    vector: Array.from({length: 1536}, () => Math.random().toFixed(6)),
                    metadata: {
                        source: section.source,
                        section_title: section.title,
                        chunk_type: "section_content",
                        word_count: section.content.split(' ').length
                    }
                }))
            };
        }

        function chunkText(text, maxLength) {
            const words = text.split(' ');
            const chunks = [];
            let currentChunk = '';
            
            for (const word of words) {
                if ((currentChunk + word).length > maxLength && currentChunk) {
                    chunks.push(currentChunk.trim());
                    currentChunk = word + ' ';
                } else {
                    currentChunk += word + ' ';
                }
            }
            
            if (currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }
            
            return chunks.length > 0 ? chunks : [text];
        }

        function parseDCPContent(content, filename) {
            if (!content || content.trim().length < 20) {
                return {
                    sections: [{
                        title: "Empty or Invalid Content",
                        content: "No readable content found in document",
                        source: filename
                    }],
                    rules: [],
                    zones: []
                };
            }

            const sections = [];
            const rules = [];
            const zones = [];

            // Clean content for better parsing
            const cleanContent = content
                .replace(/\s+/g, ' ')
                .replace(/\n\s*\n/g, '\n\n')
                .trim();

            // Extract sections using multiple patterns
            const sectionPatterns = [
                /^(\d+(?:\.\d+)*\.?\s+[A-Z][^\n\r]{5,100})[\n\r]+((?:(?!^\d+(?:\.\