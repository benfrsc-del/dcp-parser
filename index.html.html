<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCP Parser - AI-Ready Format Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.1rem;
            color: #666;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .api-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .api-section h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .api-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .api-note {
            font-size: 0.9rem;
            color: #856404;
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #ddd;
            transition: all 0.3s ease;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: scale(1.02);
        }

        .file-input-container {
            text-align: center;
            position: relative;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .file-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .file-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .file-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f1b0b7;
        }

        .processing-section {
            display: none;
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .progress-container {
            margin-bottom: 25px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #666;
        }

        .current-page {
            font-weight: 600;
            color: #333;
        }

        .processing-log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.info {
            color: #0066cc;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.warning {
            color: #ffc107;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .results-section {
            display: none;
            background: #fff;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .output-tabs {
            display: flex;
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 5px;
            flex-wrap: wrap;
        }

        .tab-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
            min-width: 120px;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .output-content {
            display: none;
        }

        .output-content.active {
            display: block;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .download-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .download-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .control-buttons {
            text-align: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            margin: 0 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .progress-details {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DCP Parser</h1>
            <p>Transform Development Control Plans into AI-ready formats with iterative page-by-page processing. Upload your PDF documents and get comprehensive structured JSON, XML, and vector embeddings.</p>
        </div>

        <div class="api-section">
            <h3>OpenAI Integration (Optional)</h3>
            <input type="password" id="apiKey" class="api-input" placeholder="Enter your OpenAI API key (sk-...)">
            <div class="api-note">
                API key is used only for generating real vector embeddings. Without it, simulated embeddings will be created.
            </div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="file-input-container">
                <input type="file" id="fileInput" class="file-input" accept=".pdf" multiple>
                <label for="fileInput" class="file-input-label">
                    Select DCP Files or Drag & Drop
                </label>
                <p style="margin-top: 15px; color: #666;">Supports PDF files up to 50MB each</p>
            </div>
            <div class="file-status" id="fileStatus"></div>
        </div>

        <div class="processing-section" id="processingSection">
            <h2>Processing Your Documents</h2>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-details">
                    <span class="current-page" id="currentPage">Initializing...</span>
                    <span id="progressPercent">0%</span>
                </div>
            </div>
            <div class="processing-log" id="processingLog"></div>
        </div>

        <div class="results-section" id="resultsSection">
            <h2>Parsing Results</h2>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="statPages">0</div>
                    <div class="stat-label">Pages Processed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statSections">0</div>
                    <div class="stat-label">Sections Found</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statRules">0</div>
                    <div class="stat-label">Development Rules</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statZones">0</div>
                    <div class="stat-label">Zoning Areas</div>
                </div>
            </div>

            <div class="output-tabs">
                <button class="tab-button active" onclick="showTab('json')">JSON Output</button>
                <button class="tab-button" onclick="showTab('xml')">XML Output</button>
                <button class="tab-button" onclick="showTab('summary')">Summary</button>
                <button class="tab-button" onclick="showTab('embeddings')">Vector Data</button>
            </div>

            <div class="output-content active" id="jsonOutput">
                <h3>Structured JSON Format</h3>
                <div class="code-block" id="jsonCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('json')">Download JSON</button>
                </div>
            </div>

            <div class="output-content" id="xmlOutput">
                <h3>XML Schema Format</h3>
                <div class="code-block" id="xmlCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('xml')">Download XML</button>
                </div>
            </div>

            <div class="output-content" id="summaryOutput">
                <h3>Document Analysis Summary</h3>
                <div class="code-block" id="summaryCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('summary')">Download Summary</button>
                </div>
            </div>

            <div class="output-content" id="embeddingsOutput">
                <h3>Vector Embeddings for AI/ML</h3>
                <div class="code-block" id="embeddingsCode"></div>
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadFile('embeddings')">Download Vectors</button>
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" onclick="processAnotherFile()">Process Another File</button>
                <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        let processedData = {};
        let processingCancelled = false;

        // Check if PDF.js loaded
        window.addEventListener('load', function() {
            if (typeof pdfjsLib === 'undefined') {
                showFileStatus('PDF.js library failed to load. Please check your internet connection.', 'error');
            } else {
                logMessage('PDF.js loaded successfully', 'success');
            }
        });

        // File input handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const fileStatus = document.getElementById('fileStatus');

        fileInput.addEventListener('change', handleFileSelect);
        uploadSection.addEventListener('dragover', handleDragOver);
        uploadSection.addEventListener('drop', handleDrop);
        uploadSection.addEventListener('dragleave', handleDragLeave);

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            logMessage(`Files selected: ${files.length}`, 'info');
            
            if (files.length > 0) {
                // Validate files
                const validFiles = files.filter(f => f.type === 'application/pdf');
                if (validFiles.length === 0) {
                    showFileStatus('Please select PDF files only', 'error');
                    return;
                }
                
                showFileStatus(`Selected ${validFiles.length} PDF file(s)`, 'success');
                processFiles(validFiles);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            uploadSection.classList.add('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = Array.from(event.dataTransfer.files).filter(f => f.type === 'application/pdf');
            
            if (files.length > 0) {
                showFileStatus(`Dropped ${files.length} PDF file(s)`, 'success');
                processFiles(files);
            } else {
                showFileStatus('Please drop PDF files only', 'error');
            }
        }

        function handleDragLeave(event) {
            uploadSection.classList.remove('dragover');
        }

        function showFileStatus(message, type) {
            fileStatus.textContent = message;
            fileStatus.className = `file-status ${type}`;
            fileStatus.style.display = 'block';
        }

        function logMessage(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            const processingLog = document.getElementById('processingLog');
            processingLog.appendChild(logEntry);
            processingLog.scrollTop = processingLog.scrollHeight;
        }

        function updateProgress(current, total, message) {
            const percentage = Math.round((current / total) * 100);
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('currentPage').textContent = message;
            document.getElementById('progressPercent').textContent = percentage + '%';
        }

        async function processFiles(files) {
            processingCancelled = false;
            logMessage(`Starting iterative processing of ${files.length} file(s)`, 'info');
            
            document.getElementById('processingSection').style.display = 'block';
            
            let totalPages = 0;
            let allPageData = [];
            let allSections = [];
            let allDevelopmentRules = [];
            let allZoningAreas = [];

            try {
                // First pass: Count total pages across all files
                logMessage('Counting total pages...', 'info');
                for (const file of files) {
                    const pageCount = await getPageCount(file);
                    totalPages += pageCount;
                    logMessage(`${file.name}: ${pageCount} pages`, 'info');
                }

                let currentPageIndex = 0;

                // Second pass: Process each file page by page
                for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {
                    if (processingCancelled) break;
                    
                    const file = files[fileIndex];
                    logMessage(`Processing file: ${file.name}`, 'info');
                    
                    try {
                        const result = await processFileIteratively(file, currentPageIndex, totalPages);
                        
                        allPageData.push(...result.pages);
                        allSections.push(...result.sections);
                        allDevelopmentRules.push(...result.rules);
                        allZoningAreas.push(...result.zones);
                        
                        currentPageIndex += result.pages.length;
                        
                        logMessage(`Completed ${file.name}: ${result.pages.length} pages processed`, 'success');
                        
                    } catch (error) {
                        logMessage(`Error processing ${file.name}: ${error.message}`, 'error');
                        // Continue with next file
                    }
                }

                if (!processingCancelled) {
                    logMessage('Analyzing extracted content...', 'info');
                    updateProgress(currentPageIndex + 1, totalPages + 5, 'Analyzing content...');
                    await sleep(300);

                    logMessage('Generating structured outputs...', 'info');
                    updateProgress(currentPageIndex + 3, totalPages + 5, 'Generating outputs...');
                    
                    // Generate embeddings
                    const apiKey = document.getElementById('apiKey').value.trim();
                    let embeddingsData;
                    
                    if (apiKey && allSections.length > 0) {
                        try {
                            logMessage('Generating real vector embeddings...', 'info');
                            embeddingsData = await generateRealEmbeddings(allSections, apiKey);
                            logMessage('Vector embeddings generated successfully', 'success');
                        } catch (error) {
                            logMessage(`Embedding generation failed: ${error.message}`, 'warning');
                            embeddingsData = generateSimulatedEmbeddings(allSections);
                        }
                    } else {
                        logMessage('Generating simulated embeddings...', 'info');
                        embeddingsData = generateSimulatedEmbeddings(allSections);
                    }

                    // Generate all outputs
                    processedData = generateStructuredOutputs({
                        files: files.map(f => f.name),
                        totalPages: allPageData.length,
                        pages: allPageData,
                        sections: allSections,
                        developmentRules: allDevelopmentRules,
                        zoningAreas: allZoningAreas,
                        embeddings: embeddingsData
                    });

                    updateProgress(totalPages + 5, totalPages + 5, 'Complete!');
                    logMessage(`Processing complete! ${allPageData.length} pages processed`, 'success');
                    
                    // Update statistics
                    document.getElementById('statPages').textContent = allPageData.length;
                    document.getElementById('statSections').textContent = allSections.length;
                    document.getElementById('statRules').textContent = allDevelopmentRules.length;
                    document.getElementById('statZones').textContent = allZoningAreas.length;

                    // Show results
                    setTimeout(() => {
                        document.getElementById('processingSection').style.display = 'none';
                        document.getElementById('resultsSection').style.display = 'block';
                        displayResults();
                    }, 1000);
                }

            } catch (error) {
                logMessage(`Processing failed: ${error.message}`, 'error');
                showFileStatus(`Processing failed: ${error.message}`, 'error');
            }
        }

        async function getPageCount(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        resolve(pdf.numPages);
                    } catch (error) {
                        reject(new Error(`Failed to count pages: ${error.message}`));
                    }
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        }

        async function processFileIteratively(file, startingPageIndex, totalPages) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        
                        const pages = [];
                        const sections = [];
                        const rules = [];
                        const zones = [];

                        // Process each page individually
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            if (processingCancelled) break;
                            
                            updateProgress(
                                startingPageIndex + pageNum, 
                                totalPages, 
                                `Processing ${file.name} - Page ${pageNum}/${pdf.numPages}`
                            );

                            try {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                
                                let pageText = '';
                                textContent.items.forEach(item => {
                                    pageText += item.str + ' ';
                                });

                                // Store page data
                                const pageData = {
                                    page_number: pageNum,
                                    source_file: file.name,
                                    content: pageText.trim(),
                                    word_count: pageText.trim().split(/\s+/).length,
                                    processed_at: new Date().toISOString()
                                };
                                pages.push(pageData);

                                // Parse content for this page
                                if (pageText.trim().length > 10) {
                                    const parsed = parseDCPContent(pageText, file.name, pageNum);
                                    sections.push(...parsed.sections);
                                    rules.push(...parsed.rules);
                                    zones.push(...parsed.zones);
                                    
                                    if (parsed.sections.length > 0 || parsed.rules.length > 0 || parsed.zones.length > 0) {
                                        logMessage(
                                            `Page ${pageNum}: Found ${parsed.sections.length} sections, ${parsed.rules.length} rules, ${parsed.zones.length} zones`, 
                                            'success'
                                        );
                                    }
                                }

                                // Small delay to prevent UI freezing
                                await sleep(50);

                            } catch (pageError) {
                                logMessage(`Error on page ${pageNum}: ${pageError.message}`, 'warning');
                                
                                // Add error page data
                                pages.push({
                                    page_number: pageNum,
                                    source_file: file.name,
                                    content: `[Error processing page: ${pageError.message}]`,
                                    word_count: 0,
                                    processed_at: new Date().toISOString(),
                                    error: true
                                });
                            }
                        }

                        resolve({ pages, sections, rules, zones });
                        
                    } catch (error) {
                        reject(new Error(`PDF processing failed: ${error.message}`));
                    }
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsArrayBuffer(file);
            });
        }

        function parseDCPContent(content, filename, pageNumber) {
            const sections = [];
            const rules = [];
            const zones = [];

            if (!content || content.trim().length < 10) {
                return { sections: [], rules: [], zones: [] };
            }

            // Enhanced section detection
            const sectionPatterns = [
                /\d+\.[\d\s]*[A-Z][^\n\r]{5,100}/g,  // Numbered sections
                /[A-Z][A-Z\s]{10,50}(?=\n|\r|$)/g,   // All caps headings
                /(?:Part|Section|Chapter)\s+[IVX\d]+[^\n\r]{0,50}/gi, // Part/Section/Chapter
                /\d+\.\d+[\s\w\-]{5,80}/g            // Sub-numbered sections
            ];

            sectionPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        sections.push({
                            title: match.trim(),
                            content: match.trim(),
                            source: filename,
                            page: pageNumber,
                            type: 'section'
                        });
                    });
                }
            });

            // Enhanced development rules extraction
            const rulePatterns = [
                {
                    type: "Building Height",
                    pattern: /(?:maximum|max)?\s*(?:building\s*)?height[:\s]*(\d+(?:\.\d+)?\s*(?:m|metres?|storeys?|floors?))/gi
                },
                {
                    type: "Floor Space Ratio",
                    pattern: /(?:FSR|floor\s*space\s*ratio)[:\s]*(\d+(?:\.\d+)?)/gi
                },
                {
                    type: "Setback",
                    pattern: /(?:front|rear|side)\s*setback[:\s]*(\d+(?:\.\d+)?\s*m)/gi
                },
                {
                    type: "Lot Coverage",
                    pattern: /(?:maximum\s*)?(?:site\s*coverage|lot\s*coverage)[:\s]*(\d+(?:\.\d+)?%?)/gi
                },
                {
                    type: "Car Parking",
                    pattern: /(?:car\s*parking|vehicle\s*parking)[:\s]*(\d+(?:\.\d+)?\s*(?:space|per|\/)?)/gi
                }
            ];

            rulePatterns.forEach(({ type, pattern }) => {
                const matches = content.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        rules.push({
                            type: type,
                            value: match.trim(),
                            source: filename,
                            page: pageNumber
                        });
                    });
                }
            });

            // Enhanced zoning extraction
            const zonePatterns = [
                /([A-Z]+\d+[A-Z]*)\s*[-–]\s*([^.\n\r]{10,80})/g,  // Code - Description
                /Zone\s+([A-
